---
menu: Doc API
name: Options
route: /doc/options/
---

import { Playground } from 'docz';
import { createElement, useState } from 'react';
import rehype2react from 'rehype-react';
import toc from 'rehype-toc';
import unifiedDoc from 'unified-doc';

import { Button, FlexLayout, Input } from '~/ui';

# Options

A `doc` can be configured with the following options:

```ts
interface Options {
  content: string;
  filename: string;
  compiler?: Compiler;
  annotations?: Annotation[];
  annotationCallbacks?: AnnotationCallbacks;
  plugins?: Plugin | Plugin[];
  sanitizeSchema?: SanitizeSchema;
  searchOptions?: SearchOptions;
  searchAlgorithm?: SearchAlgorithm;
}
```

## `content`
Refers to the source data of a `doc` provided as a string.  The following are common ways to set `content` on a `doc`.

```js
const stringContent = 'some string';
const contentFromFile = await someBlob.text();
```

## `filename`
A `doc` is usually associated with a `file` that stores `content`.  The `doc` will use the `filename` to infer the `mimeType` for the associated `content`, which determines how this `content` should be parsed.  If a `mimeType` cannot be inferred, we set it to `text/plain` as a default value.  The following shows the behaviors between `filename`, inferred `mimeTypes` and parsed `content` behaviors:

```js
// source content should be parsed as a markdown file
let content = '# Heading 1\n> some blockquote content with **strong content**';
let filename = 'doc.md';
let mimeType = 'text/markdown';
let expected = '<blockquote><strong>some</strong> markdown content</blockquote>'

// source content should be parsed as a txt file
let content = '# Heading 1\n> some blockquote content with **strong content**';
let filename = 'doc.txt';
let mimeType = 'text/plain';
let expected = '# Heading 1\n> some blockquote content with **strong content**';

// source content should be parsed as a html file
let content = '# Heading 1\n> some blockquote content with **strong content**';
let filename = 'doc.html';
let mimeType = 'text/html';
let expected = '<div># Heading 1\n> some blockquote content with **strong content**</div>';
```

<Playground>
  {() => {
    /** ====== START EDIT ======  **/
    const filename = 'doc.md'; // try: 'doc.txt', 'doc.html'
    /** ====== END EDIT ======  **/
    const content = '# Heading 1\n> some blockquote content with **strong content**';
    const doc = unifiedDoc({
      compiler: [rehype2react, { createElement }],
      content,
      filename
    });
    return doc.compile().result;
  }}
</Playground>

## `compiler`

A `compiler` compiles the source `content` into output results, usable by renderers to render a `doc`.  The default `compiler` is a string `compiler` returning HTML, but you can provide a custom `compiler` (e.g. `rehype-react`) as demonstrated in the following example.

<Playground>
  {() => {
    /** ====== START EDIT ======  **/
    const content = '# Heading 1\n> some blockquote content with **strong content**';
    /** ====== END EDIT ======  **/
    const filename = 'doc.md';
    const defaultCompiledDoc = unifiedDoc({
      content,
      filename,
    })
    const reactCompiledDoc = unifiedDoc({
      compiler: [rehype2react, { createElement }],
      content,
      filename,
    })
    return (
      <div>
        <h4>Default string compiler</h4>
        <pre>{defaultCompiledDoc.compile().contents}</pre>
        <h4>React compiler</h4>
        {reactCompiledDoc.compile().result}
      </div>
    );
  }}
</Playground>

## `annotations`

```ts
 interface Annotation {
  id: string;
  start: number;
  end: number;
  classNames?: string[];
  data?: Record<string, any>;
  style?: Record<string, any>;
}
```

Annotations describe how `text` content in a `doc` should be marked.  This is achieved by specifying  the `start` and `end` offset of the annotation relative to the `text` content.  Custom `classNames` and `styles` can be provided to customize annotations.  Overlapping annotations are also supported.

The following example demonstrates core features of annotations.  The `string()` and `text()` representation of the `doc` is provided to help visualize how annotations are processed against the `text` content of the `doc`.

<Playground>
  {() => {
    /** ====== START EDIT ======  **/
    const annotations = [
      { id: 'a', start: 0, end: 15 },
      {
        id: 'b',
        start: 8,
        end: 26,
        style: { background: 'blue', color: 'white' },
      },
      { id: 'c', start: 40, end: 55 },
    ];
    /** ====== END EDIT ======  **/
    const content = '# Heading 1\n> some blockquote content with **strong content**';
    const filename = 'doc.md';
    const doc = unifiedDoc({
      annotations,
      compiler: [rehype2react, { createElement }],
      content,
      filename
    });
    return (
      <div>
        <h4>Compiled</h4>
        {doc.compile().result}
        <h4>Text</h4>
        <pre>{doc.text()}</pre>
        <h4>String</h4>
        <pre>{doc.string()}</pre>
      </div>
    );
  }}
</Playground>

## `annotationCallbacks`

```ts
interface AnnotationCallbacks {
  onClick?: AnnotationCallback;
  onMouseEnter?: AnnotationCallback;
  onMouseOut?: AnnotationCallback;
}

type AnnotationCallback = (
  annotation: Annotation,
  event?: MouseEvent,
) => void;
```

Interactive annotations form an important feature in building annotated document applications.  `onClick`, `onMouseEnter`, `onMouseOut` behaviors can be configured with `annotationCallbacks`.

<Playground>
  {() => {
    /** ====== START EDIT ======  **/
    const annotations = [
      { id: 'a', start: 0, end: 15 },
      {
        id: 'b',
        start: 8,
        end: 26,
        style: { background: 'blue', color: 'white' },
      },
      { id: 'c', start: 40, end: 55 },
    ];
    const annotationCallbacks = {
      onClick: (annotation, event) => {
        event.stopPropagation();
        alert(`click on annotation "${JSON.stringify(annotation, null, 2)}"`);
      },
      onMouseEnter: (annotation, event) => {
        event.stopPropagation();
        console.log(`mouseenter on annotation "${annotation.id}"`);
      },
    };
    /** ====== END EDIT ======  **/
    const content = '# Heading 1\n> some blockquote content with **strong content**';
    const filename = 'doc.md';
    const doc = unifiedDoc({
      annotations,
      annotationCallbacks,
      compiler: [rehype2react, { createElement }],
      content,
      filename
    });
    return doc.compile().result;
  }}
</Playground>

## `plugins`

Valid [rehype][rehype] plugins can be provided to a `doc` to enhance features.  The following example shows how to apply a `toc` plugin:

<Playground>
  {() => {
    /** ====== START EDIT ======  **/
    const plugins = [toc]; // try '[]'
    /** ====== END EDIT ======  **/
    const content = '# Heading 1\n> some blockquote content with **strong content**';
    const filename = 'doc.md';
    const doc = unifiedDoc({
      compiler: [rehype2react, { createElement }],
      content,
      filename,
      plugins,
    });
    return doc.compile().result;
  }}
</Playground>

## `sanitizeSchema`
By default, a `doc` will be safely sanitized.  You can supply a custom schema to specify custom sanitization rules before plugins are applied.  Please see the [`hast-util-sanitize`][hast-util-sanitize] package for more details

<Playground>
  {() => {
    /** ====== START EDIT ======  **/
    // set to "{}" to use default/safe sanitization rules
    const sanitizeSchema = {
      attributes: { '*': ['style'] },
    };
    /** ====== END EDIT ======  **/
    const content = '<h1 style="background: red; color: white; font-family: impact;">Heading 1 with inline style</h1>'
    const filename = 'doc.html';
    const doc = unifiedDoc({
      compiler: [rehype2react, { createElement }],
      content,
      filename,
      sanitizeSchema,
    });
    return doc.compile().result;
  }}
</Playground>

## `searchOptions`

```ts
interface SearchOptions {
  snippetOffsetPadding?: number;
}
```

A `doc` supports a unified interface for searching (more details on this is covered in the [Methods](../methods) section).  The `searchOptions` provides a set of configurable options for any `searchAlgorithm` attached to the `doc`.

<Playground>
  {() => {
    /** ====== START EDIT ======  **/
    const searchOptions = {
      snippetOffsetPadding: 10,  // configure this
    };
    /** ====== END EDIT ======  **/
    const [query, setQuery] = useState('');
    const [results, setResults] = useState([]);
    function search(e) {
      const query = e.target.value;
      const results = doc.search(query);
      setQuery(query);
      setResults(results);
    }
    function clear() {
      setQuery('');
      setResults([]);
    }
    const content = '# Heading 1\n> some blockquote content with **strong content**';
    const filename = 'doc.md';
    const doc = unifiedDoc({
      compiler: [rehype2react, { createElement }],
      content,
      filename,
      searchOptions,
    });
    return (
      <FlexLayout flexDirection="column" space={2}>
        {doc.compile().result}
        <h4>Search</h4>
        <Input value={query} onChange={search} />
        {results.map((result, i) => {
          const [left, matched, right] = result.snippet;
          return (
            <div key={i.toString()}>
              {left}
              <strong>{matched}</strong>
              {right}
            </div>
          );
        })}
        {results.length > 0 && (
          <Button variant="secondary" onClick={clear}>
            Clear
          </Button>
        )}
      </FlexLayout>
    );
  }}
</Playground>

## `searchAlgorithm`

```ts
type SearchAlgorithm = (
  content: string,
  query: string,
  options?: Record<string, any>,
) => SearchResult[];

interface SearchResult {
  start: number;
  end: number;
  value: string;
}
```

A `searchAlgorithm` implements the behaviors of searching a `doc`. A `searchAlgorithm` implementation simply needs to return `SearchResults` containing text offsets relative to the `text` content of a `doc` when a `query` string is provided.  The `doc` will apply unified search features (e.g. snippets) on top of this algorithm.

The following example demonstrates a custom `searchAlgorithm` that pads the matched content with `'==='` strings.

<Playground>
  {() => {
    /** ====== START EDIT ======  **/
    function paddedSearchAlgorithm(content, query) {
      const searchInputRegExp = new RegExp(query, 'gi');
      const searchResults = [];
      let match;
      if (query) {
        while ((match = searchInputRegExp.exec(content)) !== null) {
          const start = match.index;
          const end = searchInputRegExp.lastIndex;
          let value = content.slice(start, end);
          if (value) {
            value = `=== ${value} ===`;
          }
          searchResults.push({ start, end, value });
        }
      }
      return searchResults;
    }
    /** ====== END EDIT ======  **/
    const [query, setQuery] = useState('');
    const [results, setResults] = useState([]);
    function search(e) {
      const query = e.target.value;
      const results = doc.search(query);
      setQuery(query);
      setResults(results);
    }
    function clear() {
      setQuery('');
      setResults([]);
    }
    const content = '# Heading 1\n> some blockquote content with **strong content**';
    const filename = 'doc.md';
    const searchOptions = { snippetOffsetPadding: 5 }
    const doc = unifiedDoc({
      compiler: [rehype2react, { createElement }],
      content,
      filename,
      searchAlgorithm: paddedSearchAlgorithm,
      searchOptions,
    });
    return (
      <FlexLayout flexDirection="column" space={2}>
        {doc.compile().result}
        <h4>Search</h4>
        <Input value={query} onChange={search} />
        {results.map((result, i) => {
          const { snippet, value } = result;
          const [left, _matched, right] = snippet;
          return (
            <div key={i.toString()}>
              {left}
              <strong>{value}</strong>
              {right}
            </div>
          );
        })}
        {results.length > 0 && (
          <Button variant="secondary" onClick={clear}>
            Clear
          </Button>
        )}
      </FlexLayout>
    );
  }}
</Playground>

<!-- Links -->
[hast-util-sanitize]: https://github.com/syntax-tree/hast-util-sanitize
[rehype]: https://github.com/rehypejs/rehype
